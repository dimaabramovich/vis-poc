<!doctype html>
<html>

<head>
  <title>Network | Circular images</title>

  <style type="text/css">
    body {
      font: 10pt arial;
    }

    #mynetwork {
      border: 1px solid black;
      background: white;
      display: inline-block;
      height: 100vh;
      width: 100vw;
    }

    .dot {
  height: 25px;
  width: 25px;
  background-color: #bbb;
  border-radius: 50%;
  display: inline-block;
}
  </style>

  <script type="text/javascript" src="./vis.js"></script>
  <script src="./data-2.js"></script>
  <link href="./vis-network.min.css" rel="stylesheet" type="text/css" />
</head>


<div id="mynetwork">

  <script>

// var svg = function (label, isFull) { 
//   let fill = (isFull ? "blue" :"white");
//   return '<svg xmlns="http://www.w3.org/2000/svg" width="390" height="65">' +
//   // '<rect x="0" y="0" width="100%" height="100%" fill="#7890A7" stroke-width="20" stroke="#ffffff" ></rect>' +
//   '<rect x="0" y="0" width="100%" height="100%" fill=' + fill +  'stroke="black" stroke-width="5" ></rect>' +
//   '<foreignObject x="15" y="10" width="100%" height="100%">' +
//   '<div xmlns="http://www.w3.org/1999/xhtml" style="font-size:40px; border-color: black">' +
//   '<span>' +
//     data +
//   '</span>' +
//   '</div>' +
//   '</foreignObject>' +
//   '</svg>';
//   }

// var url = function(data, isFull) { return "data:image/svg+xml;charset=utf-8,"+ encodeURIComponent(svg(data, isFull))};

    var level = {
      SOURCE: 0,
      DIRECT_IMPACT_ANALYSIS: 1,
      INDIRECT_IMPACT_ANALYSIS: 2
    };
    var types = {
      175: 'Profile',
      176: 'Field',
      177: 'Dashboard',
      178: 'Report',
      179: 'Page Layout',
      180: 'Approval Process',
      181: 'Assignment Rule Entry',
      182: 'Email Template',
      183: 'Flow',
      184: 'Validation Rule',
      185: 'Workflow Email Alert',
      186: 'Workflow Field Update',
      187: 'Workflow Outbound Message',
      188: 'Workflow Rule',
      189: 'Workflow Task',
      190: 'Apex Class',
      191: 'Apex Trigger',
      192: 'Visual Force Page',
      193: 'Visual Force Component',
      194: 'Lightning Page',
      195: 'Aura Component',
      196: 'Global Value Set',
      197: 'Assignment Rule',
      198: 'Picklist Value',
      199: 'Global Value Set Value',
      200: 'Mini Page Layout',
      201: 'Process Builder',
      202: 'Object',
      204: 'Permission Set',
      205: 'Apex Test Class',
      206: 'Report Type',
      207: 'Record Type',
      208: 'Aura Component App'
    };
    

    let parentsToChildMap = {};
    let parentsArray = [];
    let childToParentMap = {};
    edges.forEach(e => {
      if (!parentsToChildMap[e.from]) {
        parentsToChildMap[e.from] = [];
        parentsArray.push(e.from);
      }
      if (!childToParentMap[e.to]) {
        childToParentMap[e.to] = [];
      }
      childToParentMap[e.to].push(e.from);
      parentsToChildMap[e.from].push(e.to);
    })
    var newNodes = [];
    var sourceNode = nodes.find(n => n.relationImpact === "SOURCE");

    nodes.forEach(node => {
      let length = parentsToChildMap[node.id] ? parentsToChildMap[node.id].length : 1;
      let size = scaleFactor(length); //(length/10) + 50;
      let isVisible = parentsToChildMap[sourceNode.id].find(n => n === node.id) || node.relationImpact === "SOURCE";
      //newNodes.push({ id: node.id, label: node.displayName, group: node.objectType, relationImpact: node.relationImpact, size: size, hidden: !isVisible})
      //level: level[node.relationImpact]
      let borderWidth = ((parentsToChildMap[node.id] && parentsToChildMap[node.id].length > 0) ? '4' : '1');
      let bordercolor = ((parentsToChildMap[node.id] && parentsToChildMap[node.id].length > 0) ? 'black' : '#222222');
      newNodes.push({ id: node.id, label: node.displayName, group: node.objectType, relationImpact: node.relationImpact, level: level[node.relationImpact], hidden: !isVisible, borderWidth: borderWidth, color: {border: bordercolor}});
      // newNodes.push({ id: node.id, label: node.displayName, group: node.objectType, relationImpact: node.relationImpact, level: level[node.relationImpact], hidden: !isVisible})
    });

    var groups = [];
    newNodes.forEach(element => {
      if (!groups.find(g => g === element.group)) {
        groups.push(element.group);
      }
    });

    // create a network
    var container = document.getElementById('mynetwork');
    var data = {
      nodes: new vis.DataSet(newNodes),
      edges: edges
    };
    var options = {
      groups: {
        useDefaultGroups: false
      },
      nodes: {
        borderWidth: 1,
        size: 10,
        color: {
          // border: '#222222',
          background: '#666666'
        },
        // font: { color: 'black', background: 'white' },
        heightConstraint: true,
        // shape: 'dot',
        shape: 'box',
        // chosen :{
        //   node: true,
        //   label:true
        // }
      },
      edges: {
        color: 'lightgray',
        arrows: {
          to: { enabled: true, scaleFactor: 1, type: 'arrow' },
          middle: { enabled: false, scaleFactor: 1, type: 'arrow' },
          from: { enabled: false, scaleFactor: 1, type: 'circle' }
        },
        // physics: true,
        arrowStrikethrough: false,
        selectionWidth: 1,
        smooth: {
          enabled: true,
          "type": "cubicBezier",
          // "type": "curvedCW",
          "forceDirection": "horizontal",
          // "roundness": 0.08

          // "type": "cubicBezier",
          // "forceDirection": "horizontal",
        }
      },
      layout: {
        randomSeed: 8,
        hierarchical: {
          levelSeparation: 350, //650,
          nodeSpacing: 40,
          treeSpacing: 50,
          blockShifting: true,
          edgeMinimization: true,
          parentCentralization: true,
          direction: 'LR',        // UD, DU, LR, RL
          sortMethod: 'directed'   // hubsize, directed
        }
      },
      interaction: {
        dragNodes: false,
        hover: true,
        navigationButtons:true
      },
      physics: {
        enabled: true,
        hierarchicalRepulsion: {
          centralGravity: 0.5,
          springLength: 50,
          springConstant: 0.1,
          nodeDistance: 50,
          damping: 0.1
        },
        solver: 'hierarchicalRepulsion',
        stabilization: {
          fit: true,
          onlyDynamicEdges: true
        }
      }
    };

    var network = new vis.Network(container, data, options);
    network.fit();
    network.stabilize();
    // network.on("selectNode", function (params) {
    //   if (params.nodes.length == 1) {
    //     if (network.isCluster(params.nodes[0]) == true) {
    //       network.openCluster(params.nodes[0]);
    //     }
    //   }
    // });

    // let hoveredNode;
    // network.on("hoverNode", function (params) {
    //   hoveredNode = params.node;
    // });

    // network.on("oncontext", function (params) {
    //   if (hoveredNode){
    //     let selectedNode = newNodes.find(n => n.id === hoveredNode);
    //     if (selectedNode && selectedNode.relationImpact != 'SOURCE' && network.isCluster(hoveredNode) == false) {
    //       clusterByType(selectedNode.group);
    //       params.event.preventDefault();
    //     }
    //   }
    // });
    //selectNode

    let openedNodeMap = {};
    network.on("selectNode", function (params) {
      let children = parentsToChildMap[params.nodes[0]];
      if (children) {
          children.forEach(c => {
          // data.nodes.get(c).hidden = false;
          data.nodes.update({ id: c, hidden: !!openedNodeMap[params.nodes[0]]});
        })
        openedNodeMap[params.nodes[0]] = !openedNodeMap[params.nodes[0]];
        network.stabilize();
      }
      // if (hoveredNode){
      //   let selectedNode = newNodes.find(n => n.id === hoveredNode);
      //   if (selectedNode && selectedNode.relationImpact != 'SOURCE' && network.isCluster(hoveredNode) == false) {
      //     // clusterByType(selectedNode.group);
      //     // params.event.preventDefault();
      //   }
      // }
    });

    // groups.forEach(g => {
    //   // ['DIRECT_IMPACT_ANALYSIS', 'INDIRECT_IMPACT_ANALYSIS'].forEach(re => {
    //     clusterByType(g)
    //   // })

    // });
    function clusterByType(type) {
      let clusterOptionsByData = {
          joinCondition: function (nodeOptions) {
            return (nodeOptions.group == type ) && nodeOptions.relationImpact != 'SOURCE';
          },
          processProperties: function (clusterOptions, childNodes, childEdges) {
            
            clusterOptions.size = scaleFactor(childNodes.length);
            // clusterOptions.label = childNodes.length;
            // clusterOptions.borderWidth = 1;
            // clusterOptions.scaling = { label: { enabled: true } };
            clusterOptions.level = Math.min(...childNodes.map(n => n.level));
            return clusterOptions;
          },
          clusterNodeProperties: { id: type, borderWidth: 5, shape: 'dot', label: types[type], allowSingleNodeCluster: true, group: type}
        };
        network.cluster(clusterOptionsByData);
    }

    function scaleFactor(value){
      let factors = [{
        calc: v => v >= 1 &&  v < 10,
        value: 10
      },{
        calc: v => v >= 10 &&  v < 100,
        value: 30
      },{
        calc: v => v >= 100 &&  v < 500,
        value: 50
      },{
        calc: v => v >= 500,
        value: 100
      }];

      return factors.find(f => f.calc(value)).value;
    }


    function clusterChildren(id, children) {
      if (children.length == 0) return;
      children.push(id);

      var options = {
        joinCondition: function (clusterOptions) {
          return children.indexOf(clusterOptions.id) !== -1;
        }
      };
      network.cluster(options);
    }
  </script>

</div>
</body>

</html>