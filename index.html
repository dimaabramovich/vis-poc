<!doctype html>
<html>

<head>
  <title>Network | Circular images</title>

  <style type="text/css">
    body {
      font: 10pt arial;
    }

    #mynetwork {
      border: 1px solid black;
      background: white;
      display: inline-block;
      height: 100vh;
      width: 100vw;
    }
  </style>

  <script type="text/javascript" src="./vis.js"></script>
  <script src="./data-1.js"></script>
  <link href="./vis-network.min.css" rel="stylesheet" type="text/css" />
</head>

<div id="mynetwork">

  <script>


    var level = {
      SOURCE: 0,
      DIRECT_IMPACT_ANALYSIS: 1,
      INDIRECT_IMPACT_ANALYSIS: 2
    };
    var types = {
      175: 'Profile',
      176: 'Field',
      177: 'Dashboard',
      178: 'Report',
      179: 'Page Layout',
      180: 'Approval Process',
      181: 'Assignment Rule Entry',
      182: 'Email Template',
      183: 'Flow',
      184: 'Validation Rule',
      185: 'Workflow Email Alert',
      186: 'Workflow Field Update',
      187: 'Workflow Outbound Message',
      188: 'Workflow Rule',
      189: 'Workflow Task',
      190: 'Apex Class',
      191: 'Apex Trigger',
      192: 'Visual Force Page',
      193: 'Visual Force Component',
      194: 'Lightning Page',
      195: 'Aura Component',
      196: 'Global Value Set',
      197: 'Assignment Rule',
      198: 'Picklist Value',
      199: 'Global Value Set Value',
      200: 'Mini Page Layout',
      201: 'Process Builder',
      202: 'Object',
      204: 'Permission Set',
      205: 'Apex Test Class',
      206: 'Report Type',
      207: 'Record Type',
      208: 'Aura Component App'
    };
    

    let parentsToChildMap = {};
    let parentsArray = [];
    let childToParentMap = {};
    edges.forEach(e => {
      if (!parentsToChildMap[e.from]) {
        parentsToChildMap[e.from] = [];
        parentsArray.push(e.from);
      }
      if (!childToParentMap[e.to]) {
        childToParentMap[e.to] = [];
      }
      childToParentMap[e.to].push(e.from);
      parentsToChildMap[e.from].push(e.to);
    })
    var newNodes = [];

    nodes.forEach(node => {
      let length = parentsToChildMap[node.id] ? parentsToChildMap[node.id].length : 1;
      let size = scaleFactor(length); //(length/10) + 50;
      let isVisible = parentsToChildMap[50476660].find(n => n === node.id) || node.id === 50476660;
      newNodes.push({ id: node.id, label: node.displayName, group: node.objectType, relationImpact: node.relationImpact, size: size, hidden: !isVisible})
    });

    var groups = [];
    newNodes.forEach(element => {
      if (!groups.find(g => g === element.group)) {
        groups.push(element.group);
      }
    });

    // create a network
    var container = document.getElementById('mynetwork');
    var data = {
      nodes: new vis.DataSet(newNodes),
      edges: edges
    };
    var options = {
      groups: {
        useDefaultGroups: false
      },
      nodes: {
        borderWidth: 1,
        size: 10,
        color: {
          border: '#222222',
          background: '#666666'
        },
        font: { color: 'black', background: 'white' },
        heightConstraint: true,
        shape: 'dot',
        // chosen :{
        //   node: true,
        //   label:true
        // }
      },
      edges: {
        color: 'lightgray',
        arrows: {
          to: { enabled: true, scaleFactor: 1, type: 'arrow' },
          middle: { enabled: false, scaleFactor: 1, type: 'arrow' },
          from: { enabled: false, scaleFactor: 1, type: 'circle' }
        },
        // physics: true,
        arrowStrikethrough: false,
        selectionWidth: 1,
        smooth: {
          enabled: true,
          "type": "cubicBezier",
          // "type": "curvedCW",
          "forceDirection": "horizontal",
          // "roundness": 0.08

          // "type": "cubicBezier",
          // "forceDirection": "horizontal",
        }
      },
      layout: {
        randomSeed: 8,
        hierarchical: {
          levelSeparation: 350, //650,
          nodeSpacing: 100,
          treeSpacing: 100,
          blockShifting: true,
          edgeMinimization: true,
          parentCentralization: true,
          direction: 'LR',        // UD, DU, LR, RL
          sortMethod: 'directed'   // hubsize, directed
        }
      },
      interaction: {
        dragNodes: false,
        hover: true,
        navigationButtons:true
      },
      physics: {
        enabled: true,
        hierarchicalRepulsion: {
          centralGravity: 0.5,
          springLength: 300,
          springConstant: 0.01,
          nodeDistance: 200,
          damping: 1//0.09
        },
        solver: 'hierarchicalRepulsion',
        stabilization: {
          fit: true,
          onlyDynamicEdges: true
        }
      }
    };

    var network = new vis.Network(container, data, options);
    network.fit();
    network.on("selectNode", function (params) {
      if (params.nodes.length == 1) {
        if (network.isCluster(params.nodes[0]) == true) {
          network.openCluster(params.nodes[0]);
        }
      }
    });

    let hoveredNode;
    network.on("hoverNode", function (params) {
      hoveredNode = params.node;
    });

    network.on("oncontext", function (params) {
      if (hoveredNode){
        let selectedNode = newNodes.find(n => n.id === hoveredNode);
        if (selectedNode && selectedNode.relationImpact != 'SOURCE' && network.isCluster(hoveredNode) == false) {
          clusterByType(selectedNode.group);
          params.event.preventDefault();
        }
      }
    });
    //selectNode

    network.on("selectNode", function (params) {
      let children = parentsToChildMap[params.nodes[0]];
      if (children) {
        children.forEach(c => {
        // data.nodes.get(c).hidden = false;
        data.nodes.update({ id: c, hidden: false})
      })
      network.stabilize();
      }
      // if (hoveredNode){
      //   let selectedNode = newNodes.find(n => n.id === hoveredNode);
      //   if (selectedNode && selectedNode.relationImpact != 'SOURCE' && network.isCluster(hoveredNode) == false) {
      //     // clusterByType(selectedNode.group);
      //     // params.event.preventDefault();
      //   }
      // }
    });

    // groups.forEach(g => {
    //   // ['DIRECT_IMPACT_ANALYSIS', 'INDIRECT_IMPACT_ANALYSIS'].forEach(re => {
    //     clusterByType(g)
    //   // })

    // });
    function clusterByType(type) {
      let clusterOptionsByData = {
          joinCondition: function (nodeOptions) {
            return (nodeOptions.group == type ) && nodeOptions.relationImpact != 'SOURCE';
          },
          processProperties: function (clusterOptions, childNodes, childEdges) {
            
            clusterOptions.size = scaleFactor(childNodes.length);
            // clusterOptions.label = childNodes.length;
            // clusterOptions.borderWidth = 1;
            // clusterOptions.scaling = { label: { enabled: true } };
            clusterOptions.level = Math.min(...childNodes.map(n => n.level));
            return clusterOptions;
          },
          clusterNodeProperties: { id: type, borderWidth: 5, shape: 'dot', label: types[type], allowSingleNodeCluster: true, group: type}
        };
        network.cluster(clusterOptionsByData);
    }

    function scaleFactor(value){
      let factors = [{
        calc: v => v >= 1 &&  v < 10,
        value: 10
      },{
        calc: v => v >= 10 &&  v < 100,
        value: 30
      },{
        calc: v => v >= 100 &&  v < 500,
        value: 50
      },{
        calc: v => v >= 500,
        value: 100
      }];

      return factors.find(f => f.calc(value)).value;
    }


    function clusterChildren(id, children) {
      if (children.length == 0) return;
      children.push(id);

      var options = {
        joinCondition: function (clusterOptions) {
          return children.indexOf(clusterOptions.id) !== -1;
        }
      };
      network.cluster(options);
    }
  </script>

</div>
</body>

</html>